# 以太坊开发步骤之四： 权证与ERC标准

从一个开发者角度来看，以太坊权证就是简化的智能合约。如果拿饮料来对比，就如同任何人都可以用自己的方式调配出适合自己口味的咖啡。

大家也可能听说过ERC20，ERC721，或者其它标准，他们都是开发者社区共同遵守的[基础功能](https://github.com/ethereum/EIPs)，在此基础上，大家都可以使用自己开发功能，以自己的方式创建脚本来管理虚拟货币。

加勒比海盗中有一句台词很好地再现了这个情况：
[the code is more like guidelines, RATHER THAN ACTUAL RULES"](https://github.com/hokingyang/learngit/blob/master/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B9%8B%E5%9B%9B%E6%9D%83%E8%AF%81%E4%B8%8EERC.jpeg)


长远看，遵循标准有很多益处。首先，如果遵照标准生成权证，那么每个人都会知道它是如何产生，并知道如何和它打交道，因此就会有更多信任。例如，DApps，跟Mist很像，大家都会认为它是一种权证，并通过特定的UI来与其打交道。另外，一种权证智能合约标准实现已经被社区开发出来，它采用类似[OpenZeppelin](https://github.com/OpenZeppelin/zeppelin-solidity)的架构。这种实现已经被很多大神验证过，可以用来作为权证开发的起点。

本文中会从头开始提供一个不完整的，但是遵循ERC20标准的，基础版的权证实现，然后将它转换成遵循ERC721标准的实现。这样就会看出两个标准之间的不同。写本文的出发点是希望大家了解权证如何工作，其过程并不是一个黑箱；另外，对于ERC20这个标准，尽管它至少已经被广泛接受两年以上，如果只是从标准框架简单地生成自己的权证，也还会存在某些看不见的风险点。

## 生成自己权证

[ERC20](https://theethereum.wiki/w/index.php/ERC20_Token_Standard)是为可替代权证标准设立的标准，它可以被其它应用（从钱包到去中心化交易）重用。可替代意味着可以用同类的权证互换，换句话说，所有的权证都是等价的（就像钱币，某一美金和其它美金之间没有区别）。而一个不可替换权证代表一种特定价值（例如房屋，财产，艺术品等）。可替代权证有其内在价值，而不可替代权证只是一种价值智能合约的代表。

要提供符合ERC20标准的权证，需要实现如下功能和事件：

标准不提供功能的实现，这是因为大家可以用自己喜欢的方式写出任何代码，如果不需要提供某些功能只需要[按照标准](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)返回null/false的值就可以了。
> 注意：本文并不很强调代码，大家只需了解内部机理，全部代码将会在文末附上链接。


## 实现

首先，需要给权证起一个名字，因此会采用一个公有变量:

其次给一个符号：

当然还要有具体小数位数：
>因为Solidity并不完全支持浮点数，因此必须把所有数表示成整数。例如，如果使用2位小数，那么“123456”代表“1234.56”；如果采用4位小数，则代表“12.3456”。0位小数代表权证不可分。而以太坊的加密币以太币则使用18位小数。
>一般地，权证不需要使用18位小数，因为它被神圣的以太币加持过了（除非你愿意被其它专家指责为什么采用这个神圣的数字）。

需要统计一共发行了多少权证，并跟踪每人拥有多少：

当然需要从0个权证开始，除非在权证智能合约创建时候就生成了一些，如下例：

"totalsupply()"函数只是从totalSupply变量中获取数值：

“balanceOf()”也是类似的函数：

“transfer()”函数是将权证从一个地址发送到另外一个地址的函数

以上基本就是ERC20权证标准的核心内容。

“approve()”, “transferFrom()”, 和 “allowance()”   是使得权证符合ERC20标准一致性的函数，但是它们[容易受到攻击](https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)。当源地址 “approve()” 另外一个被授权地址，被授权地址就可以使用“transferFrom()” 函数花费源地址里的权证。 “allowance()”  只是一个从其它地址获得可用额度的函数。

这些函数都有安全隐患，因为当源地址向被授权地址授信可以花费X个权证后，有突发原因需要将授信改成Y个权证，被授权地址很有可能在重新授信实现之前将X个权证转移走；当Y个权证的新授信完成后，又可以转移Y个权证。在之前的本系列文章中我提到过，当某个交易正处在挖矿过程中时状态不能确定，旷工可以在交易挖矿过程中篡改信息。

鉴于ERC20还存在其他一些问题，更安全容错的“transferFrom()” 实现和其它方案被发布出来（如之前所说，标准只是一些功能原型和行为定义，如何实现则靠开发者自己实现），并正在讨论中，其中就包括[ERC223](https://github.com/ethereum/EIPs/issues/223)和[ERC777](https://github.com/ethereum/EIPs/issues/777).

ERC223方案的动机是避免将权证发送到错误地址或者不支持这种权证的合约上，成千上万的金钱因为上述原因丢失，这一需求作为以太坊后续开发功能的[第223条记录](https://github.com/ethereum/EIPs/issues/223)在案。ERC777则实现在完成其它功能的同时，对接收地址进行“即将收到权证”的提醒功能，ERC777方案看起来很有可能替代ERC20.


## ERC721

目前看，ERC721跟ERC20有本质上的不同。ERC721中，权证都是唯一的。ERC721是几个月前提出来的方案，[CryptoKitties](https://en.wikipedia.org/wiki/Cryptokitties)，这款使用ERC721标准实现的收集虚拟猫游戏使得它很受瞩目。虚拟猫游戏实际就是智能合约中的不可替代权证，并在游戏中用猫的形象来表现出来。

如果想将一个ERC20合约转变成ERC721合约，我们需要知道ERC721如何跟踪权证。在ERC20中，每个地址都有一个账目表，而在ERC721合约中，每个地址都有一个权证列表：

由于Solidity自身限制，不支持对队列进行“indexOF()”  的操作，不得不手动进行队列权证跟踪：

当然可以用自己实现的代码库来发现元素的索引，考虑到有可能很长的索引时间，最佳实践还是采用映射方式。

为了更容易跟踪权证，还可以为权证的拥有者设置一个映射表：

以上就是两个标准之间最大的不同，ERC721中的“transfer()” 函数会为权证设置新的拥有者：

尽管代码比较长，但却是移动权证流程中必不可少的步骤。

还必须注意，ERC721也有“approve()” 和 “transferFrom()” 方法，因此在transfer函数内部，必须加上其它限制指令，这样被授权地址就无法对改变拥有者的权证进行转移操作，看起来像如下过程：


## 挖矿

基于以上两种标准，可能面对同一种需求，要么产生可替代权证，要么产生不可替代权证，一般都会用一个叫做“Mint()”的函数完成。

实现以上功能函数的代码如下：

用随机数产生一个新权证，根据不同应用场景，一般在合约内部只会授权一个地址可以对它进行挖矿（mint）操作。

这里需要注意，“mint()” 函数并没有出现在协议标准定义中，而是我们添加上去的，也就是我们可以对标准进行扩充，添加其它对权证的必要操作。例如，可以添加一个买卖一定数量以太币的系统，或者删除不再需要权证的功能。

## 元数据

如前所述，不可替代权证是价值的代表，大量情况下，需要描述这种价值。可以用如下字符串实现：

由此可见，智能合约与其说内含某种对象不如说是一种权益的证明。例如，不能将一辆车存放在智能合约中，但是可以存放车证或者其它合法票证。

目前虚拟价值广泛使用的技术都使用IPFS哈希作为元数据，[IPFS](https://medium.com/@ConsenSys/an-introduction-to-ipfs-9bba4860abd0)哈希是存放在IPFS系统中文件的地址。简单说，IPFS是一个HTTP的torren版本。当一个新文件添加到IPFS中，就会在IPFS网络中的至少一个计算节点上表现出来。

当文件通过IPFS或者HTTP对每个人都可见是，“拥有权证明”就在智能合约中注册。这个操作不是程序，而应该是不可替代权证的应用。它被称为“Crypto-collectibles”，现在变得很热门。

回到我们的代码，ERC721的讨论目前不太活跃了，原始建议贴很久都没有更新过，因此基于此又有新的讨论方案，被称为[ERC841](https://github.com/ethereum/EIPs/pull/841)。在ERC841中“不可替代权证”被“deeds”的称呼替代。另外一个方案，[ERC821](https://github.com/ethereum/EIPs/issues/821)，也被提出来，期望基于ERC223和ERC777提供更好的方案设计。
ERC821和ERC841有同样的目标，但是实现方法上有些许不同，但都有待改进，如果大家有建议，可以参与讨论。

可以在Github上找到ERC20和ERC721的实现（不建议上生产），链接为：[devzl/ethereum-walkthrough-4](https://github.com/devzl/ethereum-walkthrough-4)

另外，花点儿时间了解[OpenZepplin框架](https://github.com/OpenZeppelin/zeppelin-solidity/)也是值得的。

以上就是第四部分的内容，[下一篇](https://hackernoon.com/ethereum-development-walkthrough-part-5-making-a-dapp-4c2a3bbcd5e5)中我们将介绍[如何创建DApp](https://hackernoon.com/ethereum-development-walkthrough-part-5-making-a-dapp-4c2a3bbcd5e5)。

如果喜欢本文，可以通过如下方式联系我：[@dev_zl](https://twitter.com/dev_zl)

## 彩蛋：ICO和crowdsales

Initial coin offerings (ICOs)有点儿偏离以太坊项目开发的议题，但是本质上，它就是一种众筹。如果一个初创公司需要资金，就可以创建自己的权证，过一段时间卖一部分，被称做crowdsale或者ICO。

在智能合约和区块链技术出现之前，初创公司会使用[众筹网站](https://en.wikipedia.org/wiki/Crowdfunding)集资，但是这种网站会抽走很大一部分服务费。有了ICO之后，没有了中间商，筹集的钱都归初创公司自己用了。

目前，集资项目更多的是骗局，从投资者角度看，应该看好自己的钱袋。从开发者角度看，crowdsale就是一种智能合约，它卖的是未来兑换以太币的权证。没有一个标准方式，但是可以从OpenZepplin代码库中找到一些好的[实现方式](https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/crowdsale)。另外，在以太坊上也有一个[简易教程](https://ethereum.org/crowdsale).
